---
title: Module Action Definitions
sidebar_label: Action Definitions
sidebar_position: 16
description: Module action definition details.
---

Actions are the heart of many modules: they define what will happen when a user pushes a button or runs a trigger.

This section explains how to define actions, provide options to the user, and respond when the user invokes the action.

## Control flow (API calls)

API calls: `setActionDefinitions()`

Your module defines the list of actions it supports by making a call to [`this.setActionDefinitions({ ...some actions here... })`](https://bitfocus.github.io/companion-module-base/classes/InstanceBase.html#setactiondefinitions). You will need to do this as part of your `init()` method, but can also call it at any other time if you wish to update the list of actions exposed.

Note: Please try not to do it too often, as updating the list has a cost. If you are calling it multiple times in a short span of time, consider if it would be possible to batch the calls so it is only done once.

## Action definitions

The [TypeScript module template](https://github.com/bitfocus/companion-module-template-ts) includes a file `src/actions.ts` which is where your actions should be defined. It is not required to use this structure, but it keeps it more readable than having everything in one file. More complex modules will likely want to split the actions definitions into even more files/folders.

All the actions are passed in as a single javascript object, in the form of:

```js
{
  'action1' : { properties of action 1 },
  'action2' : { properties of action 2 },
  'action3' : { properties of action 3 }
}
```

The minimum action definition looks like:

```js
{
    name: 'My first action',
    options: [],
    callback: (action) => {
        console.log('Hello World!')
    }
}
```

### Callbacks: synchronous and asynchronous

The callback function is called when the action is executed (i.e. associate button is pressed). Callback functions may either execute synchronously and return `undefined`, or asynchronously and return a promise that resolves `undefined` (including by directly returning in an `async` function).

Before Companion 3.5, when a series of actions was executed, each action's callback would be called in sequence, with no delay between actions (unless an action was defined with a relative or absolute delay) and no waiting for asynchronous callback functions' returned promises to resolve or reject. From Companion 3.5 onward, actions may be defined to run **in sequence** (by putting them in an action-group in the Admin interface) -- waiting for the promise returned by an asynchronous callback function to resolve before continuing. If you want your action to support delaying subsequent actions until completed, you must write your callback to not resolve the promise it returns until the action has completed. For example:

```js
const actions = [
	// This action will begin to make a http request and subsequent sequential actions
	// will execute before the request is finished.
	{
		name: 'Fetch Google',
		options: [],
		callback: (action) => {
			fetch('https://google.com/').then(
				() => {
					console.log('request complete')
				},
				() => {
					console.log('request failed')
				}
			)
		},
	},
	// This action will begin to make a request and subsequent sequential actions
	// won't execute until the request is finished.
	{
		name: 'Fetch Google and wait',
		options: [],
		callback: async (action) => {
			return fetch('https://google.com/').then(
				() => {
					console.log('request complete')
				},
				() => {
					console.log('request failed')
				}
			)
		},
	},
]
```

### Additional properties

There are more properties available, which are described in full in [the autogenerated Actions documentation on GitHub](https://bitfocus.github.io/companion-module-base/interfaces/CompanionActionDefinition.html)

The `options` property of the action definition is an array of input types, as defined [here](./input-field-types.md)

### Using variables

:::note

As of [`@companion-module/base#v1.13`](../api-changes/companion-4.1.md) (Companion 4.1), variables in textinput fields are now automatically parsed.

:::

As of `@companion-module/base#v1.1.0`, a `context` object is passed as the second argument in the `callback`, `subscribe`, `unsubscribe` and `learn` callbacks.

_TODO: Was the following true for actions or only feedbacks?_

The `context` object includes a special version of the `parseVariablesInString()` method that allows Companion to recheck those variables on each callback. If you use `parseVariablesInString` off the `InstanceBase` class instead, your callback will **not** be rechecked when variables change. The full definition of this type is [here](https://bitfocus.github.io/companion-module-base/interfaces/CompanionActionContext.html).

## Further Reading

- [Input-field Types (Options)](./input-field-types.md)
- [Upgrade scripts](./upgrade-scripts.md)
- [Autogenerated Actions documentation on GitHub](https://bitfocus.github.io/companion-module-base/interfaces/CompanionActionDefinition.html)
- [`context` argument documentation on GitHub](https://bitfocus.github.io/companion-module-base/interfaces/CompanionActionContext.html)
- [Autogenerated docs for the module `InstanceBase` class](https://bitfocus.github.io/companion-module-base/classes/InstanceBase.html)

Actions also support the following advanced features:

- [subscribe & unsubscribe flow](../connection-advanced/subscribe-unsubscribe-flow.md)
- [learn option values](../connection-advanced/learn-action-feedback-values.md)
- [result to custom variable](../connection-advanced/setting-custom-variables.md)
